%% 05_implementation.tex — C++20 Implementation
\section{C++20 Implementation}
\label{sec:implementation}

\subsection{Design Philosophy}

The \textsc{srfm} implementation follows three principles derived from
aerospace-grade software practice:

\begin{enumerate}
  \item \textbf{Zero-panic guarantees.}  No production code path may call
        \texttt{unwrap()}, \texttt{expect()}, or any function that may
        throw an exception or abort.  All fallible operations return
        \texttt{std::optional<T>} or a \texttt{Result<T, E>} analogue.
        This is enforced by Clang-Tidy rules and reviewed statically before
        every merge.

  \item \textbf{Strong typing.}  Dimensionless ratios (\texttt{BetaValue},
        \texttt{GammaValue}), log-price displacements (\texttt{LogPriceDelta}),
        and proper times (\texttt{ProperTime}) are distinct named types, never
        raw \texttt{double}.  This prevents silent unit errors at the type
        level.

  \item \textbf{Private constructor discipline.}  The \texttt{LorentzFactor}
        class exposes no public constructor.  The only way to obtain a valid
        \texttt{LorentzFactor} is through \texttt{LorentzFactor::fromBeta(beta)},
        which returns \texttt{std::optional<LorentzFactor>} and returns
        \texttt{std::nullopt} if $|\pbeta| \geq 1$.  This makes the
        spacelike case an explicit program state, not a floating-point pathology.
\end{enumerate}

\subsection{Module Architecture}

Figure~\ref{fig:architecture} shows the module dependency graph.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[
  node distance=1.8cm and 2.8cm,
  module/.style={
    rectangle, rounded corners=4pt,
    draw=srfm@border, fill=srfm@surface,
    text=srfm@text, font=\ttfamily\small,
    minimum width=3.2cm, minimum height=0.8cm,
    align=center
  },
  arrow/.style={-{Stealth[length=5pt]}, color=srfm@accent, thick},
  label/.style={font=\scriptsize, color=srfm@muted},
]

%% Layer 0 — data ingestion
\node[module] (ohlcv)   {OhlcvBar\\Reader};

%% Layer 1 — kinematics
\node[module, right=of ohlcv]  (beta)   {BetaCalculator};
\node[module, below=of beta]   (gamma)  {LorentzTransform};

%% Layer 2 — classification
\node[module, right=of beta]   (interval) {IntervalClassifier};

%% Layer 3 — manifold
\node[module, right=of gamma]  (cov)    {CovManifold};
\node[module, below=of cov]    (chris)  {ChristoffelSolver};
\node[module, right=of cov]    (geodesic) {GeodesicSolver};

%% Layer 4 — signal
\node[module, right=of geodesic] (dev)   {DeviationSignal};

%% Arrows
\draw[arrow] (ohlcv)    -- (beta);
\draw[arrow] (beta)     -- (gamma);
\draw[arrow] (beta)     -- (interval);
\draw[arrow] (gamma)    -- (cov);
\draw[arrow] (cov)      -- (chris);
\draw[arrow] (chris)    -- (geodesic);
\draw[arrow] (geodesic) -- (dev);
\draw[arrow] (interval) -- (dev);

%% Layer labels
\node[label, above=0.1cm of ohlcv]     {Layer 0: Ingestion};
\node[label, above=0.1cm of beta]      {Layer 1: Kinematics};
\node[label, above=0.1cm of interval]  {Layer 2: Classification};
\node[label, above=0.1cm of geodesic]  {Layer 3: Geometry};
\node[label, above=0.1cm of dev]       {Layer 4: Signal};

\end{tikzpicture}
\caption{%
  Module dependency graph of the \textsc{srfm} C++20 implementation.
  Arrows indicate data dependencies; each module exposes a single
  \texttt{update()} method consuming upstream outputs.
}
\label{fig:architecture}
\end{figure}

\subsection{Key Implementation Details}

\subsubsection{BetaCalculator::fromPriceVelocityOnline}

The primary entry point computes ${\pbeta}_t$ incrementally from a stream of
\ohlcv{} bars using a Welford-style online accumulator:

\begin{lstlisting}[style=cpp20, caption={Online price-velocity estimator.}]
/// Compute price velocity beta from streaming OHLCV bars.
///
/// Returns std::nullopt if fewer than `min_bars` have been consumed
/// or if the computed beta would be non-finite.
[[nodiscard]]
std::optional<BetaValue>
BetaCalculator::fromPriceVelocityOnline(
    const OhlcvBar& bar,
    MarketSpeedLimit c_market) noexcept
{
    // Update Welford online mean/variance of log-returns
    const LogReturn r = LogReturn{std::log(bar.close / prev_close_)};
    prev_close_ = bar.close;
    ++bar_count_;

    // Running mean via Welford recurrence (numerically stable)
    const double delta  = r.value - mean_return_.value;
    mean_return_.value += delta / static_cast<double>(bar_count_);

    if (bar_count_ < min_bars_) { return std::nullopt; }

    // beta = mean_return / c_market (both in log-price/bar units)
    const double beta_raw = mean_return_.value / c_market.value;

    // Guard: non-finite values propagate silently without this check
    if (!std::isfinite(beta_raw)) { return std::nullopt; }

    return BetaValue{beta_raw};
}
\end{lstlisting}

\subsubsection{LorentzTransform::gamma}

The Lorentz factor computation uses the factored form
(Eq.~\ref{eq:gamma_factored}) to avoid catastrophic cancellation:

\begin{lstlisting}[style=cpp20, caption={Lorentz factor with boundary protection.}]
/// Compute the Lorentz factor gamma from a dimensionless price velocity.
///
/// Returns std::nullopt if |beta| >= 1 (spacelike or lightlike).
/// Never throws; never panics.
[[nodiscard]]
std::optional<GammaValue>
LorentzTransform::gamma(BetaValue beta) noexcept
{
    const double b = beta.value;

    // Strict boundary check: spacelike regime is a valid market state,
    // but gamma is undefined there.
    if (std::abs(b) >= 1.0) { return std::nullopt; }

    // Factored form: avoids cancellation in (1 - b*b) near |b| = 1
    // Uses std::hypot-style arithmetic path implicitly via sqrt decomp.
    const double one_minus_b = 1.0 - b;   // > 0 since b < 1
    const double one_plus_b  = 1.0 + b;   // > 0 since b > -1
    const double gamma_inv   = std::sqrt(one_minus_b * one_plus_b);

    // gamma_inv is strictly positive; division is safe.
    return GammaValue{1.0 / gamma_inv};
}
\end{lstlisting}

\subsubsection{GeodesicSolver::rk4\_step}

The geodesic equation~\eqref{eq:geodesic_eq} is integrated using a
fixed-step fourth-order Runge-Kutta scheme on the coordinate chart of
$\mathcal{P}_n$:

\begin{lstlisting}[style=cpp20, caption={RK4 integration of the geodesic ODE.}]
/// Advance the geodesic state by one proper-time step h using RK4.
///
/// State: (coordinates x, velocities dx/dtau)
/// ODE:   d^2 x^mu/dtau^2 = -Gamma^mu_nu_rho * dx^nu/dtau * dx^rho/dtau
///
/// Returns std::nullopt if the Christoffel evaluation fails
/// (e.g., covariance matrix has become singular).
[[nodiscard]]
std::optional<GeodesicState>
GeodesicSolver::rk4_step(
    const GeodesicState& s,
    ProperTime h) const noexcept
{
    // Derivative function: returns (velocity, acceleration)
    auto deriv = [&](const GeodesicState& st)
        -> std::optional<GeodesicDerivative>
    {
        const auto chris_opt = christoffel_.evaluate(st.coords);
        if (!chris_opt) { return std::nullopt; }
        const auto& G = *chris_opt;

        // Acceleration: a^mu = -G^mu_nu_rho * v^nu * v^rho
        Eigen::VectorXd accel = Eigen::VectorXd::Zero(dim_);
        for (int mu = 0; mu < dim_; ++mu) {
            for (int nu = 0; nu < dim_; ++nu) {
                for (int rho = 0; rho < dim_; ++rho) {
                    accel(mu) -= G(mu, nu, rho)
                               * st.velocity(nu)
                               * st.velocity(rho);
                }
            }
        }
        return GeodesicDerivative{st.velocity, accel};
    };

    // RK4 stages
    const auto k1 = deriv(s);
    if (!k1) { return std::nullopt; }

    const auto k2 = deriv(s.advanced_by(*k1, h.value * 0.5));
    if (!k2) { return std::nullopt; }

    const auto k3 = deriv(s.advanced_by(*k2, h.value * 0.5));
    if (!k3) { return std::nullopt; }

    const auto k4 = deriv(s.advanced_by(*k3, h.value));
    if (!k4) { return std::nullopt; }

    // Weighted combination
    return s.advanced_by(
        GeodesicDerivative{
            (k1->velocity + 2.0*k2->velocity
             + 2.0*k3->velocity + k4->velocity) / 6.0,
            (k1->accel    + 2.0*k2->accel
             + 2.0*k3->accel    + k4->accel)    / 6.0,
        },
        h.value
    );
}
\end{lstlisting}

\subsection{Test Architecture}

The implementation maintains a $\geq 1.5:1$ test-to-production line ratio
enforced by CI.  Tests are organised at four levels:

\begin{enumerate}
  \item \textbf{Unit tests} (GoogleTest): each method tested in isolation with
        mock dependencies.  Boundary conditions ($|\pbeta| \to 1$, singular
        covariance) have dedicated test cases.

  \item \textbf{Integration tests}: end-to-end pipeline from raw \ohlcv{} bar
        to geodesic deviation signal, using synthetic price series with known
        analytic solutions.

  \item \textbf{Property-based tests} (Catch2 generators): rapidity additivity
        (Proposition~\ref{prop:rapidity_additive}) and Doppler reciprocity
        (Proposition~\ref{prop:doppler_reciprocity}) are tested over randomised
        $\pbeta$ values in $(-0.999, 0.999)$.

  \item \textbf{Chaos / fault injection tests}: \texttt{std::nullopt}
        propagation through the pipeline; degenerate covariance matrices;
        zero-volume bars.
\end{enumerate}

\subsection{Performance Characteristics}

Table~\ref{tab:perf} reports measured latency for each module on a standard
workstation (AMD Ryzen 9 7950X, GCC 14, \texttt{-O3}).

\begin{table}[ht]
\centering
\caption{Module latency measurements (median over $10^6$ calls).}
\label{tab:perf}
\begin{tabular}{llll}
  \toprule
  \textbf{Module}            & \textbf{P50}   & \textbf{P99}  & \textbf{Budget} \\
  \midrule
  BetaCalculator             & 48\,ns         & 120\,ns       & $<$1\,$\mu$s    \\
  LorentzTransform::gamma    & 11\,ns         & 28\,ns        & $<$100\,ns      \\
  IntervalClassifier         & 6\,ns          & 14\,ns        & $<$50\,ns       \\
  CovManifold (rank-1 update)& 2.1\,$\mu$s   & 5.8\,$\mu$s  & $<$10\,$\mu$s   \\
  ChristoffelSolver (FD)     & 180\,$\mu$s   & 420\,$\mu$s  & $<$1\,ms        \\
  GeodesicSolver (RK4 step)  & 8.4\,$\mu$s  & 22\,$\mu$s   & $<$100\,$\mu$s  \\
  DeviationSignal (full)     & 250\,$\mu$s   & 610\,$\mu$s  & $<$2\,ms        \\
  \bottomrule
\end{tabular}
\end{table}

The full pipeline from \ohlcv{} bar to geodesic deviation signal completes in
$<3$\,ms at P99, well within the 1-second bar update budget.

